四、技术现状
（说明：介绍与本发明最接近的现有技术方案及工作过程。如果检索结果中有多篇相似专利，应选择最有能体现本方案发明点的专利作为现有技术介绍。现有技术的缺点应该是本发明应该可以解决的，如果不能解决的缺点不要提及。）
在WebGIS应用中，面对大量点状地理要素加载和渲染：

在WebGIS应用中，数据的展示经历了两个阶段，第一阶段是将矢量要素通过后台进行金字塔分层切割，切成一张张固定大小的图片(常用的256*256大小),然后浏览器请求这些图片进行拼接成一张地图在前端显示，这种方案能保证速度以及渲染压力，但是在前端显示的是图片，无法做到要素级别的交互，优点明显，缺点同样明显。
第二阶段，主要是针对第一阶段的实现方式的弊端提出的，同样是切片 但是切出来的是一个个矢量数据文件，浏览器通过解析文件，在前端Cavas上一个个要素绘制上去，由于不是图片，我们可以动态的改变要素的样式，同时还能做到要素级别的交互，针对要素级别的交互目前现有的技术方案有以下两种:
1、	要素级别事件注册：
在地图上每添加一个地理要素，比如一个点、线、或面，都对这个要素进行事件注册，注册点击事件 注册滑入滑出事件，注册双击事件。该方法能保证要素的快速拾取，但是当地图展示的要素过多，以及要素变更频繁的时候，对要素的销毁 事件的销毁，要素添加 事件添加等需要大量的内存开销。
2、	要素查询：
通过像素位置去和地理要素进行位置匹配，将匹配出来的地理要素进行相应的交互操作，这种方法省掉了大量的事件注册过程，能加快地理要素的更新和渲染，但是需要大量的空间运算，当数据量达到一定的数量级的时候，这个效率问题需要重点考虑。
那么有没有这样一种机制，既不用进行海量事件注册、销毁的维护过程，同时又能快速的拾取地理要素进行交互操作，该篇方案就是对这种问题提出一种解决思路。
《矢量切片的要素编码及拾取方案》能在不需要事先注册事件的情况下快速的拾取地理要素，并根据地理要素进行相关交互，测试在1000万地理要素的拾取速度达到400ms，能高速有效拾取，同时和拾取后对要素进行样式调整或信息显示，从而达到高交互的矢量交互诉求
五、技术方案
《矢量切片的要素编码及拾取方案》是在浏览器端通过像素快速拾取地理要素的一套完整的解决WebGIS中海量地理要素快速拾取的解决方案。
5.1 技术方案设计图
 
该方案关键点在于对地理要素进行编码生成HashCode以及对目标点进行编码和地理要素的HashCode进行比对拾取。后面重点说明地理要素的编码和比对拾取过程。
5.1.1 地理要素编码
	地理要素编码过程是整个方案的关键环节，也是后面拾取的关键，这里以切片的默认大小是256*256为例进行编码说明。如图 5-1-1 是一张256*256的单张切片，我们对整张切片进行编码，0表示地理要素不经过该像素点 1表示地理要素经过该像素点，这样当我们对要素进行编码的时候就会产生一个256×256大小的二维矩阵,这里以16*16的矩阵来缩略表示，说明编码规则，如下图 左侧的编码部分表示在切片中间部分是一个矩形的面状要素，右侧是具体的切片，图上的红色填充要素是一个8×8像素大小的点，我们可以看到它的大小和一个POI图标的大小相当，256*256对我们来说相对太大，所以在编码完成后，我们还需要对矩阵进行压缩，压缩过程以及压缩原因后面编码的压缩部分进行具体说明。
上述部分是对地理要素的单张切片进行编码，但是我们知道一副切片地图是由很多切片拼接起来的，那么怎么确定你鼠标拾取的位置的切片呢，这就涉及到第二部分的编码，对切片进行编码；切片编码相对简单按照行列号进行编码，如果一张切片的行号是54008 列号是10456 那么该切片的唯一编码是54008-10456
切片的行列号计算公式：
行号=(origin.y-point.y)/(resolution*256)
列号=(point.x-origin.x)/(resolution*256)
  

（5-1-1）
5.1.2 点要素的编码
 
点的编码只需要简单的将矩阵中点对应的位置的值设置为1即可完成编码过程
5.1.3 线要素的编码
  
   线要素的编码继承点要素的编码，复杂的地方是将两个端点连接线的途经点全部进行编码，这样在编码矩阵中1值是一个连续的线状区域
5.1.4 面要素的编码
  
   面要素编码继承线的编码，在完成边线的编码后使用fill方法进行填充，这里采用像素级别的射线法进行填充面，具体判断规则如下
 
当以目标点为起点向右绘制射线，当射线与边线相交的个数是奇数个则该点在面内，该点的值设置为1 否则为0 
5.1.5 矩阵编码压缩
   我们对地理要素是按照256×256的单张切片进行的，对一个地理要素编码完成会导致编码很大同时编码时间也会很长，同时考虑到我们鼠标的识别点的精度和容差因素，我们在编码的过程中采用8*8个像素作为一个编码点，如上图5-1-1中的红色填充矩形
直观上的对比，8*8像素大小也相当于一个POI图标的大小，所以这样压缩是很有必要，这样能保证我们的拾取更高效，只要在8*8的范围内有1编码为1 整个压缩过程如下
编码压缩前
 
编码压缩
 
压缩后
 
5.1.6 要素拾取
   通过上面5步，我们完成了切片的地理要素的编码，那么我们就可以基于这些编码进行快速的要素拾取，而不需要通过空间运算
1.	获取鼠标点击位置的地理坐标 point
2.	计算当前位置所在的切片编码   行号:(origin.y-point.y)/(256*resolution)
列号(point.x-origin.x)/(256*resolution)
      切片编码为：行号-列号
3.	计算鼠标点击处的位置，相对于当前切片 x=(tileOrigin.y-point.y)/( resolution)
                                     y=( point.x- tileOrigin.x)/( resolution)
4.	遍历地图上的features
If(feature.id=行号-列号 && features.HashCode[x][y]==1){
		return true;
}
   当然这里涉及到一个边界的处理问题，在前面步骤5中我们对编码进行了压缩，但是当我们鼠标点击位置处在编码矩阵的边缘时会导致由于压缩的存在使得要素无法拾取出来，所以在拾取的时候我们做了一下特殊处理，我们将压缩的8*8的矩形区域划分为4部分如下图 1 2 3 4区域 ，那么在拾取过程中做如下处理
a.	如果鼠标拾取点在1区域  那么A B D区域的要素也会被拾取到。 
b.	如果鼠标拾取点在2区域  那么B C E区域的要素也会被拾取到。
c.	如果鼠标拾取点在3区域  那么D F G区域的要素也会被拾取到。
d.	如果鼠标拾取点在4区域  那么E G H区域的要素也会被拾取到。
 
5.3 应用场景
	《矢量切片的要素编码及拾取方案》适合的使用场景：在地图上矢量要素的快速拾取
	《矢量切片的要素编码及拾取方案》适合的使用场景：地图要素的交互以及事件机制全覆盖
	《矢量切片的要素编码及拾取方案》适合的使用场景：地理要素的快速查询

六、 本发明的创新点和欲保护点及其带来的有益效果
1.创新点
  1）《矢量切片的要素编码及拾取方案》—将矢量数据进行预先动态编码，使得在对地理要素的查询过程能跳过耗时的空间查询部分，能快速的拾取地理要素并能保证拾取时间在毫秒级别
2）《矢量切片的要素编码及拾取方案》—能够克服要素交互时，注册大量的要素级交互事件，从而提高浏览器的性能
2.有益效果
1）可解决地图要素展示时的可交互性，同时配合鼠标的交互事件完成各种动态效果。
2）在数据查询的时候能脱离后端服务器的空间查询，直接在前台页面进行拾取，同时能保证高效性
（说明：提炼出本发明技术方案的关键创新点即区别于现有技术的不同之处，分别说明每一点不同之处给本技术方案带来了哪些区别于现有技术的有益效果。）

七、 其他有助于专利代理人理解本技术的资料


