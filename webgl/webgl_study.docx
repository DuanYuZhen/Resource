webgl思路：
--------用颜色值清空面板
—获取canvas
—获取webgl的绘制内容//要判断是否获取成功
—设置清空绘图区的颜色（其实将颜色存到了gl.COLOR_BUFFER_BIT）
—取出颜色，清空绘图区

--------画点
—定义顶点着色器：顶点位置，顶点大小
—定义片元着色器：片元色值
—初始化着色器//要判断是否初始化成功
—从gl.program中获取顶点着色器的变量位置//判断是否获取成功
—给位置上的变量赋值
—在画布上绘制点


顶点着色器的坐标是：
—x向右为正，范围是负一到一
—y向上为正，范围是负一到一
—z（深度坐标）向屏幕外为正。

变量类型：
—矢量或者成为向量类型：vec4是由4个浮点数组成的一个矢量
—浮点类型：float

顶点着色器内置变量：
—gl_Position:存放顶点位置的，是vec4类型的
—gl_PointSize:存放顶点大小像素的，是float类型的。
片元着色器内置变量：
—gl_FragColor:存放顶点颜色的，是vec4类型的。

齐次坐标是4位的坐标（x,y,z,w）,  w必须是大于等于0的，w趋近于0，表示的点趋近于无穷远。
而顶点的坐标是三维的，通常用齐次坐标表示顶点的三维坐标时，第4位设置为1.0

WebGL—API：
—gl.drawArrays(mode,first,count);
mode: gl.POINTS、gl.LINES、gl.LINE_STRIP、gl.LINE_LOOP、gl.TRIANGLES、gl.TRIANGLE_STRIP、gl.TRIANGLE_FAN
first：从哪个点绘制 –整型
count：绘制几个点 –整型
—gl.getAttribLocation(gl.program,变量名);
	gl.program是在初始化着色器时获取的
	变量名是顶点着色器中的变量名
	返回在gl.program中的变量位置。获取失败，返回值小于0；反之成功。
—gl.vertexAttrib3f(变量位置,x,y,z);
根据变量位置，用顶点坐标给变量赋值
变量位置只能存储一个顶点的值


内容：
线绘制

注记绘制

模型读取

坐标系（900913）

光照 

阴影

优化

图层背景色实现优化 （baseLayer 不透明 其它透明）

Render Render2 Location shader 代码优化

hgis1.x的几个组件 视情况

行车轨迹

三大包围圈

热力图

聚合

可视域

1. 当前渲染实现是由功能驱动的，没有任何设计，加入不同类型的功能，需要我们在Render中添加draw×××()方法  从组织数据到 draw到渲染器都要全部一一实现，上新功能会繁琐且要求高
2. gl 深度测试 等webgl行为控制，只能做到 Render这一层，有的数据来需要开启 有的不需要开启，我们不能做到这一点，其它 比如颜色混合等等也如此，  比如在z值相同的地方叠加多个面绘制乱掉的问题，目前粗暴的关闭深度测试
3. featurechanged 粒度太粗，当一个要素改变所有的都要重绘，达不到设计初衷，同时 同步和异步也没有区别对待，期望能将数据分块，要素变更只更新变更数据所在数据块的数据
4. 光照控件 是针对所有功能的，需要提炼，索性整体考虑
5. 带边框的面 这类组合要素的绘制 在数据相同的情况下，我们需要切换不同的Program来完成一个要素的绘制，
6. 期望渲染和js执行分开，能达到浏览器执行权优先渲染，在空闲的时间去做数据组织 要素拾取编码等，不会因为这些耗时的前端运算占用浏览器资源导致渲染卡顿，这样不会导致后续我们一些外围的功能叠加导致系统越来越
jiangjinwei(江金伟) 12-12 14:04:14
慢
7. 将redraw分为 有数据更新的重绘和没有数据更新的重绘，目前重绘制都会重新向GPU 全量拷贝数据 ，拆解后要达到 有数据更新才拷贝数据，相机变化等 不需全量拷贝数据，同时在样式更新等 不会影响buffer长度的情况下，直接进行局部更新。
